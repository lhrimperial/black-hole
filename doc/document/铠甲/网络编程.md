##### Java 网络编程

##### 一、Socket

1. socket概念

   Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用，它是一组接口。

<img src="/Users/longhairen/Documents/geek_time/netty/A8E4C366-E136-4660-8069-C91DA376AE37.png" alt="A8E4C366-E136-4660-8069-C91DA376AE37" style="zoom:50%;" />

下图是典型的基于 Socket 的通信的场景：

![image017](/Users/longhairen/Documents/geek_time/netty/image017.jpg)

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。

2. 建立通信链路

   当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。

   与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。

   <img src="/Users/longhairen/Documents/geek_time/netty/1652f12fa745cb4f.png" alt="1652f12fa745cb4f" style="zoom:70%;" />

3. 数据传输

   传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。

   当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。

   

   > socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。
   >
   > 数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。网络文件通过fd读写对应缓冲区。

4. BIO带来的挑战

   BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞，在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，服务端需要同时保持大量的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。

   使用线程池想法是好的，现实很残酷，因为在阻塞式I/O模型下，使用线程池本身就是一个伪命题。  
   线程池的工作原理是，内部维护了一系列线程，接受到一个任务时，会找出一个当前空闲的线程来处理这个任务，这个任务处理完成之后，再将这个线程返回到池子中。
   而在阻塞式IO中，因为需要不断的检查一个client是否有新的请求，也就是调用其read方法，而这个方法是阻塞的，意味着，一旦调用了这个方法，如果没有读取到数据，那么这个线程就会一直block在那里，一直等到有数据，等到有了数据的时候，处理完成，立即由需要进行下一次判断，这个client有没有再次发送请求，如果没有，又block住了，因此可以认为，线程基本上是用一个少一个，因为对于一个client如果没有断开连接，就相当于这个任务没有处理完，任务没有处理完，线程永远不会返回到池子中，直到这个client断开连接。

> server端的终极目标：**"server端应该使用尽可能少的线程，来处理尽可能多的client请求"**
>
> UNIX五种IO模型中，读取数据都必须要经过的两个阶段：
> 阶段1、等待数据准备
> 阶段2、将准备好的数据从内核空间拷贝到用户空间
>
> 对于阶段1，其等待时间可能是无限长的，因为一个与server已经建立连接的client，可能很长时间内都没有发送新的请求。
> 对于阶段2，只是将数据从内核空间拷贝到用户空间，这个时间实际上是很短的
>
> 由于在Blocking IO模型中，进程是不区分这两个阶段的，把其当做一个整体来运行（这对应于Socket的getInputStream方法返回的InputStream 对象的read方法，这个方法不区分这两个阶段）。因此在没有数据准备好的情况下，是一直被阻塞的。而我们前面的代码， worker thread在不知道client有没有新的数据的情况下， 直接尝试去读取数据，因此线程被block住。
>
> 如果我们有一种机制，可以对这两个阶段进行区分。
> 那么我们就可以用一个专门的线程去负责第一阶段：这个线程去检查有哪些client准备好了数据，然后将这些client过滤出来，交给worker线程去处理；而worker线程只负责第二阶段：因为第一个阶段已经保证了当前处理的client肯定是有数据的，这样worker线程在读取的时候，阻塞时间是很短的，而不必经历第一阶段那样长时间的等待。
> 这实际上就是UNIX 五种IO模型中的多路复用模型。



##### 二、NIO（Nonblocking I/O）

通道 和 缓冲区 是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。

通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。

#####Buffer

![nio-buffer](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/io/nio-buffer.png)

1. 概念上，缓冲区是包在一个对象内的基本数据元素数组。 Buffer 类相比一个简单数组的优点 是它将关于数据的数据内容和信息包含在一个单一的对象中。 Buffer 类以及它专有的子类定义了 一个用于处理数据缓冲区的 API。

   Buffer类定义了所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息。

```java
public abstract class Buffer {
...
// Invariants: mark <= position <= limit <= capacity
  private int mark = -1;
  private int position = 0;
  private int limit;
  private int capacity;
...
}
```

- **容量（ Capacity）**

缓冲区能够容纳的数据元素的最大数量，可以理解为数组的长度。 这一容量在缓冲区创建时被设定，并且永远不能被改变。

- **上界（ Limit）**

缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。

- **位置（ Position）**

下一个要被读或写的元素的索引。Buffer类提供了get( )和 put( )函数 来读取或存入数据，position位置会自动进行相应的更新。

- **标记（ Mark）**

一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的(undefined)。

> 这四个属性之间总是遵循以下关系：
>
> 0 <= mark <= position <= limit <= capacity

2. API 

   Buffer类定义了所有缓冲区实现类需要实现的方法，以下列出的只是这些方法的签名，不包含实现

   ```java
   public abstract class Buffer {
       //JDK1.4时，引入的api
       public final int capacity( )//返回此缓冲区的容量
       public final int position( )//返回此缓冲区的位置
       public final Buffer position (int newPositio)//设置此缓冲区的位置
       public final int limit( )//返回此缓冲区的限制
       public final Buffer limit (int newLimit)//设置此缓冲区的限制
       public final Buffer mark( )//在此缓冲区的位置设置标记
       public final Buffer reset( )//将此缓冲区的位置重置为以前标记的位置
       public final Buffer clear( )//清除此缓冲区
       public final Buffer flip( )//反转此缓冲区
       public final Buffer rewind( )//重绕此缓冲区
       public final int remaining( )//返回当前位置与限制之间的元素数
       public final boolean hasRemaining( )//告知在当前位置和限制之间是否有元素
       public abstract boolean isReadOnly( );//告知此缓冲区是否为只读缓冲区
    
       //JDK1.6时引入的api
       public abstract boolean hasArray();//告知此缓冲区是否具有可访问的底层实现数组
       public abstract Object array();//返回此缓冲区的底层实现数组
       public abstract int arrayOffset();//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量
       public abstract boolean isDirect();//告知此缓冲区是否为直接缓冲区
   }
   ```

   存取函数包含在子类，以ByteBuffer类为例进行说明：

   ```java
   public abstract class ByteBuffer {
    
       //缓冲区创建相关api
       public static ByteBuffer allocateDirect(int capacity)
       public static ByteBuffer allocate(int capacity)
       public static ByteBuffer wrap(byte[] array)
       public static ByteBuffer wrap(byte[] array,int offset, int length)
    
       //缓存区存取相关API
       public abstract byte get( );//从当前位置position上get，get之后，position会自动+1
       public abstract byte get (int index);//从绝对位置get
       public abstract ByteBuffer put (byte b);//从当前位置上普通，put之后，position会自动+1
       public abstract ByteBuffer put (int index, byte b);//从绝对位置上put
    
   }
   ```

   新的缓冲区是由分配(allocate)或包装(wrap)操作创建的。allocate操作创建一个缓冲区对象并分配一个私有的空间来储存容量大小的数据元素。wrap操作创建一个缓冲区对象但是不分配任何空间来储存数据元素。它使用您所提供的数组作为存储空间来储存缓冲区中的数据元素。 

   存储操作是通过get和put操作进行的，get 和 put 可以是相对的或者是绝对的。在前面的程序列表中，相对方案是不带有索引参数的函数。当相对函数被调用时，位置在返回时前进一。如果位置前进过多，相对运算就会抛 出 异 常 。 对 于 put() ， 如 果 运 算 会 导 致 位 置 超 出 上 界 ， 就 会 抛 出BufferOverflowException 异常。对于 get()，如果位置不小于上界，就会抛出BufferUnderflowException 异常。绝对存取不会影响缓冲区的位置属性，但是如果您所提供的索引超出范围（负数或不小于上界），也将抛出 IndexOutOfBoundsException 异常。

##### Channel

通道(Channel)可以理解为数据传输的管道。通道与流不同的是，流只是在一个方向上移动(一个流必须是inputStream或者outputStream的子类)，而通道可以用于读、写或者同时用于读写。

![nio-channel](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/io/nio-channel.jpg)

一个 channel 类可能实现定义read( )方法的 ReadableByteChannel 接口，而另一个 channel 类也许实现 WritableByteChannel 接口以提供 write( )方法。

```java
public interface ReadableByteChannel extends Channel {
    public int read(ByteBuffer dst) throws IOException;
}
 
public interface WritableByteChannel extends Channel{
    public int write(ByteBuffer src) throws IOException;
}
```

实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据。

可以看到read和write方法接受的都是一个ByteBuffer参数，其中read方法，就是往ByteBuffer中put数据，write方法就是将ByteBuffer中的数据get出来，以便发送给其他远程主机。

两种方法均返回已传输的字节数，可能比缓冲区的字节数少甚至可能为零。缓冲区的position位置也会发生与已传输字节相同数量的前移。如果只进行了部分传输，缓冲区可以被重新提交给通道并从上次中断的地方继续传输。该过程重复进行直到缓冲区的 hasRemaining( )方法返回 false 值。

SocketChennal通道详解

SocketChannel实现了读写接口，而 ServerSocketChannel不实现， ServerSocketChannel 负责监听传入的连接和创建新的 SocketChannel 对象，它本身从不传输数据。 NIO中的socket 通道类（ DatagramChannel、 SocketChannel 和 ServerSocketChannel）在被实例化时都会创建一个对等的BIO中的 socket 对象（ Socket、 ServerSocket和 DatagramSocket），通道类都定义了socket()方法，我们可以通过这个方法获取其关联的socket对象。另外每个Socket、 ServerSocket和 DatagramSocket都定义了getChannel()方法，来获取对应的通道。

>**非阻塞模式**
>
>通道可以以阻塞（ blocking）或非阻塞（ nonblocking）模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。
>
>我们可以通过调用configureBlocking(boolean)方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。而 isBlocking()方法来判断某个 socket 通道当前处于哪种模式.

1. ServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket执行相同的基本任务，不过它增加了通道语义，因此能够在非阻塞模式下运行。如果您选择在 ServerSocket 上调用 accept( )方法，那么它会同任何其他的 ServerSocket 表现一样的行为：总是阻塞并返回一个 java.net.Socket 对象。如果您选择在 ServerSocketChannel 上调用 accept( )方法则会返回 SocketChannel 类型的对象，返回的对象能够在非阻塞模式下运行。如果以非阻塞模式被调用，当没有传入连接在等待时， ServerSocketChannel.accept( )会立即返回 null。

2. SocketChannel

   SocketChannel，它是使用最多的 socket 通道类：

   Socket 和 SocketChannel 类封装点对点、有序的网络连接，就是我们所熟知并喜爱的 TCP/IP网络连接。 SocketChannel 扮演客户端发起同一个监听服务器的连接。直到连接成功，它才能收到数据并且只会从连接到的地址接收。

   每个 SocketChannel 对象创建时都是同一个对等的 java.net.Socket 对象串联的。静态的 open( )方法可以创建一个新的 SocketChannel 对象，而在新创建的 SocketChannel 上调用 socket( )方法能返回它对等的 Socket 对象；在该 Socket 上调用 getChannel( )方法则能返回最初的那个 SocketChannel。

   新创建的 SocketChannel 虽已打开却是未连接的。在一个未连接的 SocketChannel 对象上尝试一个 I/O 操作会导致 NotYetConnectedException 异常。我们可以通过在通道上直接调用 connect( )方法或在通道关联的 Socket 对象上调用 connect( )来将该 socket 通道连接。一旦一个 socket 通道被连接，它将保持连接状态直到被关闭。您可以通过调用布尔型的 isConnected( )方法来测试某个SocketChannel 当前是否已连接。

##### Selector

选择器提供选择执行已经就绪的任务的能力，这使得多元 I/O 成为可能，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道(channels)。

我们需要将创建的一个或多个可选择的`Channel`注册到`Selector`对象中，一个键(`SelectionKey`)将会被返回。SelectionKey 会记住您关心的通道。它们也会追踪对应的通道是否已经就绪。<img src="/Users/longhairen/Documents/geek_time/netty/1483540103154037014.png" alt="1483540103154037014" style="zoom:75%;" />

每个Channel在注册到Selector上的时候，都有一个感兴趣的操作。

- 对于`ServerSocketChannel`，只会在选择器上注册一个，其感兴趣的操作是ACCEPT，表示其只关心客户端的连接请求
- 对于`SocketChannel`，通常会注册多个，因为一个server通常会接受到多个client的请求，就有对应数量的SocketChannel。SocketChannel感兴趣的操作是CONNECT、READ、WRITE，因为其要于server建立连接，也需要进行读、写数据。

从最基础的层面来看，选择器提供了询问通道是否已经准备好执行每个 I/0 操作的能力。例如，我们需要了解一个 SocketChannel 对象是否还有更多的字节需要读取，或者我们需要知道ServerSocketChannel 是否有需要准备接受的连接。

  当调用一个Selector对象的 select( )方法时，相关的SelectionKey 会被更新，用来检查所有被注册到该选择器的通道是否已经准备就绪。也就是说，程序需要主动的去调用Selector.select()方法。 select() 方法会返回一个准备就绪的SelectionKey的集合。通过遍历这些键，您可以选择出每个从上次您调用 select( )开始直到现在，已经就绪的通道。

1. 创建选择器

   Selector 对象是通过调用静态工厂方法 open( )来实例化的。类方法 open( )向 SPI 发出请求，通过默认的 SelectorProvider 对象获取一个新的实例。通过调用一个自定义的 SelectorProvider对象的 openSelector( )方法来创建一个 Selector 实例。

2. 注册通道到选择器上

   注册通道到选择器上，是通过register方法进行的。

   通道在被注册到一个选择器上之前，必须先设置为非阻塞模式（通过调用 `configureBlocking(false)`）。

   如果您试图注册一个处于阻塞状态的通道， `register`( )将抛出未检查的 IllegalBlockingModeException 异常。此外，通道一旦被注册，就不能回到阻塞状态。试图这么做的话，将在调用 configureBlocking( )方法时将抛出`IllegalBlockingModeException `异常。并且，理所当然地，试图注册一个已经关闭的 SelectableChannel 实例的话，也将抛出`ClosedChannelException `异常，就像方法原型指示的那样。

   register( )方法接受一个 Selector 对象作为参数，以及一个名为ops 的整数参数。第二个参数表示所关心的通道操作，返回值是一个SelectionKey。

   ```java
   public final SelectionKey register(Selector sel, int ops)
   ```

   ops值在 SelectonKey 类中被定义为 public static 字段。

   ```java
   public abstract class SelectionKey {
   ...
   public static final int OP_READ = 1 << 0;
   public static final int OP_WRITE = 1 << 2;
   public static final int OP_CONNECT = 1 << 3;
   public static final int OP_ACCEPT = 1 << 4;
   ...
   }
   ```

   **可以看到有四种被定义的可选择操作：读(read)，写(write)，连接(connect)和接受(accept)。**

   可以通过调用通道的 validOps( )方法来获取特定的通道所支持的操作集合,SocketChannel支持的validOps ：

   ```java
   public abstract class SocketChannel...{
   ....
   public final int validOps() {
       return (SelectionKey.OP_READ
               | SelectionKey.OP_WRITE
               | SelectionKey.OP_CONNECT);
   }
   ....
   }
   ```

   ServerSocketChannel的validOps

   ```java
   public abstract class ServerSocketChannel..{
   ...
   public final int validOps() {
       return SelectionKey.OP_ACCEPT;
   }
   ...
   }
   ```

   一个通道可以被注册到多个选择器上，但对每个选择器而言，最好只注册一次。如果一个Selector上多次注册同一个Channel，返回的SelectionKey总是同一个实例，后注册的感兴趣的操作类型会覆盖之前的感兴趣的操作类型。 一个channel在不同的selector上注册， 每次返回的selectorKey都是一个不同的实例。

3. 选择键(SelectionKey)

   SelectionKey对象被register( )方法 返回，并提供了方法来表示表示这种注册关系。

   ```java
   public abstract SelectableChannel channel( ); //获得这个SelectionKey关联的channel
   public abstract Selector selector( ); //获得这个selectionKey关联的Selector
   ```

   同时选择键包含指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。

   ```java
   public abstract int interestOps( );//感兴趣兴趣的操作
   public abstract int readyOps( );//感兴趣的操作中，已经准备就绪的操作
   ```

   可以通过调用键的 `readyOps`( )方法来获取相关的通道的已经就绪的操作。 ready 集合是 interest集合的子集 。当前的 interest 集合可以通过调用键对象的 `interestOps`( )方法来获取。最初，这应该是通道被注册时传进来的值。

   SelectionKey 类定义了四个便于使用的布尔方法来测试这些比特值： `isReadable`( )， `isWritable`( )， `isConnectable`( )， 和 `isAcceptable`( )。每一个方法都与使用特定掩码来测试 readyOps( )方法的结果的效果相同。

   ```java
   if (key.isWritable( ))
   等价于：
   if ((key.readyOps( ) & SelectionKey.OP_WRITE) != 0)
   ```

4. 当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。

5. 使用选择器

   ```java
   public abstract class Selector{
   // This is a partial API listing
   public abstract Set keys( );
   public abstract Set selectedKeys( );
   public abstract int select( ) throws IOException;
   public abstract int select (long timeout) throws IOException;
   public abstract int selectNow( ) throws IOException;
   public abstract void wakeup( );
   }
   ```

   **每一个 Selector 对象维护三个键的集合**：

   - **已注册的键的集合(Registered key set)**

     与选择器关联的已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过keys( )方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引 java.lang.UnsupportedOperationException。

   - **已选择的键的集合(Selected key set)**

     已注册的键的集合的子集。这个集合的每个成员都是相关的通道被选择器（在前一个选择操作中）判断为已经准备好的，并且包含于键的 interest 集合中的操作。这个集合通过 selectedKeys( )方法返回（并有可能是空的）。

   - **已取消的键的集合(Cancelled key set)**

     已注册的键的集合的子集，这个集合包含了 cancel( )方法被调用过的键（这个键已经被无效 化），但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。

6. 选择过程

   Selector 类的核心是选择过程。这个名词您已经在之前看过多次了——现在应该解释一下了。基本上来说，选择器是对 select( )、 poll( )等本地调用(native call)或者类似的操作系统特定的系统调用的一个包装。但是 Selector 所作的不仅仅是简单地向本地代码传送参数。它对每个选择操作应用了特定的过程。对这个过程的理解是合理地管理键和它们所表示的状态信息的基础。

   Selector 类的 select( )方法有以下三种不同的形式：

   ```java
   public abstract int select( ) throws IOException;
   public abstract int select (long timeout) throws IOException;
   public abstract int selectNow( ) throws IOException;
   ```

   这三种 select 的形式，仅仅在它们在所注册的通道当前都没有就绪时，是否阻塞的方面有所不同。最简单的没有参数的形式可以用如下方式调用：

   1. **select()，**这种调用在没有通道就绪时将无限阻塞。一旦至少有一个已注册的通道就绪，选择器的选择键就会被更新，并且每个就绪的通道的 ready 集合也将被更新。返回值将会是已经确定就绪的通道的数目。正常情况下， 这些方法将返回一个非零的值，因为直到一个通道就绪前它都会阻塞。但是它也可以返回非 0 值，如果选择器的 wakeup( )方法被其他线程调用。
   2. **select (long timeout)** ：有时您会想要限制线程等待通道就绪的时间。这种情况下，可以使用一个接受一个超时参数的select( long timeout)方法的重载形式：这种调用与之前的例子完全相同，除了如果在您提供的超时时间（以毫秒计算）内没有通道就绪时，它将返回 0。如果一个或者多个通道在时间限制终止前就绪，键的状态将会被更新，并且方法会在那时立即返回。将超时参数指定为 0 表示将无限期等待，那么它就在各个方面都等同于使用无参数版本的 select( )了。
   3. **selectNow()**方法执行就绪检查过程，但不阻塞。如果当前没有通道就绪，它将立即返回 0。

7. 停止选择

   Selector 的 API 中的最后一个方法， wakeup( )，提供了使线程从被阻塞的 select( )方法中优雅地退出的能力：

   ```java
   public abstract void wakeup( );
   ```

   有三种方式可以唤醒在 select( )方法中睡眠的线程：

   **调用 wakeup( )**

   调用 Selector 对象的 wakeup( )方法将使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有在进行中的选择，那么下一次对 select( )方法的一种形式的调用将立即返回。后续的选择操作将正常进行。在选择操作之间多次调用 wakeup( )方法与调用它一次没有什么不同。

   **调用 close( )**

   如果Selector的 close( )方法被调用，那么任何一个在选择操作中阻塞的线程都将被唤醒，就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销， 而键将被取消。

   **调用 interrupt( )**

   如果睡眠中的线程的 interrupt( )方法被调用，它的返回状态将被设置。如果被唤醒的线程之后将试图在通道上执行 I/O 操作，通道将立即关闭，然后线程将捕捉到一个异常。这是由于在第三章中已经探讨过的通道的中断语义。使用 wakeup( )方法将会优雅地将一个在 select( )方法中睡眠的线程唤醒。如果您想让一个睡眠的线程在直接中断之后继续执行，需要执行一些步骤来清理中断状态（参见 Thread.interrupted( )的相关文档）。Selector 对象将捕捉 InterruptedException 异常并调用 wakeup( )方法。请注意这些方法中的任意一个都不会关闭任何一个相关的通道。中断一个选择器与中断一个通道是不一样的。选择器不会改变任意一个相关的通道，它只会检查它们的状态。当一个在 select( )方法中睡眠的线程中断时，对于通道的状态而言，是不会产生歧义的。

#### 三、Netty

Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建。

> 不建议使用NIO的原因
>
> - NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。
> - 需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。
> - 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，IO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。
> - JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。
>
> 选择Netty的理由
>
> 1. Netty 做得更多:
>    • 支持常用应用层协议;
>    • 解决传输问题:粘包、半包现象; • 支持流量整形;
>    • 完善的断连、Idle 等异常处理等。
> 2. Netty 做得更好之一
>    - 规避 JDK NIO bug:  经典的 epoll bug :异常唤醒空转导致 CPU 100%，IP_TOS 参数( IP 包的优先级和 QoS 选项)使用时抛出异常
>    - “踏平”多少 JDK NIO bug:5646
> 3. Netty 做得更好之二:API 更友好更强大
>    - JDK 的 NIO 一些 API 不够友好，功能薄弱，例如 ByteBuffer -> Netty’s ByteBuf
>    - 除了 NIO 外，也提供了其他一些增强:Theadlocal -> Netty’s FastThreadLocal
> 4. Netty 做得更好之三:隔离变化、屏蔽细节
>    - 隔离 JDK NIO 的实现变化: nio -> nio2(aio)-> ....
>    - 屏蔽 JDK NIO 的实现细节

##### Reactor线程模型

reactor线程模型其是一种并发编程模型，更确切的或者说一种思想，其具有的是指导意义，开发者需要在这种编程模型思想的指导下，结合自己的实际场景，来进行合理的设计。在不同的场景下，可能设计出来的reactor线程模型是不一样的，例如scala中的akka框架，就是基于reactor线程模型的思想设计的。换句话说，netty只是结合了nio网络编程的特点，合理的应用了reactor线程模型。

reactor线程模型关注的是：任务接受之后，对处理过程继续进行切分，划分为多个不同的步骤，每个步骤用不同的线程来处理，也就是原本由一个线程处理的任务现在由多个线程来处理，每个线程在处理完自己的步骤之后，还需要将任务转发到线程继续进行处理。为了进行区分，在reactor线程模型中，处理任务并且分发的线程，不再称之为worker thread，而是reactor thread。

Netty中的Reactor线程模型

![1486130747296085576](/Users/longhairen/Documents/geek_time/netty/1486130747296085576.png)



理解NioEventLoop和NioEventLoopGroup
- NioEventLoop实际上就是工作线程，可以直接理解为一个线程。NioEventLoopGroup是一个线程池，线程池中的线程就是NioEventLoop。
- 实际上bossGroup中有多个NioEventLoop线程，每个NioEventLoop绑定一个端口，也就是说，如果程序只需要监听1个端口的话，bossGroup里面只需要有一个NioEventLoop线程就行了。
- 每个NioEventLoop都绑定了一个Selector，所以在Netty的线程模型中，是由多个Selecotr在监听IO就绪事件。而Channel注册到Selector。
- 一个Channel绑定一个NioEventLoop，相当于一个连接绑定一个线程，这个连接所有的ChannelHandler都是在一个线程中执行的，避免了多线程干扰。更重要的是ChannelPipline链表必须严格按照顺序执行的。单线程的设计能够保证ChannelHandler的顺序执行。
- 一个NioEventLoop的selector可以被多个Channel注册，也就是说多个Channel共享一个EventLoop。EventLoop的Selecctor对这些Channel进行检查。

##### Netty 组件

1. ##### Channel

   Netty中通道是对java原生网络编程api的封装，其顶级接口是Channel。

   以TCP编程为例 ，在java中，有两种方式：

   - 基于BIO，JDK1.4之前，我们通常使用java.net包中的`ServerSocket`和`Socket`来代表服务端和客户端。
   - 基于NIO，Jdk1.4引入nio编程之后，我们使用java.nio.channels包中的`ServerSocketChannel`和`SocketChannel`来代表服务端与客户端。

   在Netty中，对java中的BIO、NIO编程api都进行了封装，分别：

   - 使用了`OioServerSocketChannel`，`OioSocketChannel`对java.net包中的ServerSocket与Socket进行了封装
   - 使用`NioServerSocketChannel`和`NioSocketChannel`对java.nio.channels包中的ServerSocketChannel和SocketChannel进行了封装。

   **Netty中TCP编程的Channel类图继承关系如下：**

   ![netty-channel](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/netty/netty-channel.png)

   NioServerSocketChannel和NioSocketChannel中有对应的java通道，可以看到这二者都继承自AbstractNioChannel，其维护了netty中的channel与java nio中channel的对应关系，并提供了javaChannel()方法获取对应的java 中的channel：

   ```java
   public abstract class AbstractNioChannel extends AbstractChannel {
    ...
   private final SelectableChannel ch;
    ...
    protected SelectableChannel javaChannel() {//获取对应的java通道
       return ch;
    }
   }
   ```

   SelectableChannel是java nio中的类，我们前面提到nio包中的SocketChannel、ServerSocketChannel都是其子类，NioSocketChannel和NioServerSocketChannel对AbstractNioChannel的javaChannel()进行了覆写，如下：

   ```java
   io.netty.channel.socket.nio.NioServerSocketChannel#javaChannel
   @Override
   protected ServerSocketChannel javaChannel() {//返回java.nio.channels.ServerSocketChannel
     return (ServerSocketChannel) super.javaChannel();
   }
   
   io.netty.channel.socket.nio.NioSocketChannel#javaChannel
   @Override
   protected SocketChannel javaChannel() {//返回java.nio.channels.SocketChannel
       return (SocketChannel) super.javaChannel();
   }
   ```

   NioServerSocketChannel和NioSocketChannel在构造方法中会创建对应的ServerSocket和Socket实例，以NIOServerSocketChannel为例：

   ```java
   public class NioServerSocketChannel extends AbstractNioMessageChannel
                                implements io.netty.channel.socket.ServerSocketChannel {
       private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
       private static ServerSocketChannel newSocket(SelectorProvider provider) {
           try {
              return provider.openServerSocketChannel();
           } catch (IOException e) {
               throw new ChannelException(
                       "Failed to open a server socket.", e);
           }
       }
   
       public NioServerSocketChannel() {
           this(newSocket(DEFAULT_SELECTOR_PROVIDER));
       }
   
       public NioServerSocketChannel(SelectorProvider provider) {
           this(newSocket(provider));
       }
   
     public NioServerSocketChannel(ServerSocketChannel channel) {
           super(null, channel, SelectionKey.OP_ACCEPT);
           config = new NioServerSocketChannelConfig(this, javaChannel().socket());
       }
       ……
   }
   
   io.netty.channel.nio.AbstractNioChannel 构造方法
   public abstract class AbstractNioChannel extends AbstractChannel {
       private final SelectableChannel ch;
       protected final int readInterestOp;
       volatile SelectionKey selectionKey;
   
        protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
           super(parent);
           this.ch = ch;
           this.readInterestOp = readInterestOp;
           try {
   	          //设置为非阻塞
               ch.configureBlocking(false);
           } catch (IOException e) {
               try {
                   ch.close();
               } catch (IOException e2) {
                   if (logger.isWarnEnabled()) {
                       logger.warn(
                               "Failed to close a partially initialized socket.", e2);
                   }
               }
   
               throw new ChannelException("Failed to enter non-blocking mode.", e);
           }
       }
   }
   ```

   NioSocketChannel也是类似的创建过程。通常Channel实例，在创建的时候，就会创建其对应的ChannelConfig实例。

2. #####ChannelConfig

   在Netty中，每种Channel都有对应的配置，用ChannelConfig来表示，ChannelConfig是一个接口，每个特定的Channel实现类都有自己对应的ChannelConfig实现类，如：

   NioSocketChannel的对应的配置类为NioSocketChannelConfig

   NioServerSocketChannel的对应的配置类为NioServerSocketChannelConfig
   ![netty-channel-config](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/netty/netty-channel-config.png)

   在Channel接口中定义了一个方法config()，用于获取特定通道实现的配置，子类需要实现这个接口。

   ```java
   public interface Channel extends AttributeMap, Comparable<Channel> {
   ...
   ChannelConfig config();
   ...
   }
   ```

   **Netty提供了一个`ChannelOption`类，其定义了ChannelConfig支持的所有参数类型**，可以认为ChannelConfig中用了一个Map来保存参数，Map的key是ChannelOption，ChannelConfig 定义了相关方法来获取和修改Map中的值。

   ```java
   public interface ChannelConfig {
   ...
       Map<ChannelOption<?>, Object> getOptions();//获取所有参数
      boolean setOptions(Map<ChannelOption<?>, ?> options);//替换所有参数
      <T> T getOption(ChannelOption<T> option);//获取以某个ChannelOption为key的参数值
      <T> boolean setOption(ChannelOption<T> option, T value);//替换某个ChannelOption为key的参数值
   ....
   }
   ```

   想修改某项参数，通过Channel对象获取对应的ChannelConfig来设置

   ```java
   Channel ch = ...;
      SocketChannelConfig cfg = (SocketChannelConfig) ch.getConfig();
      cfg.setOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
      
      或者
      
      Channel ch = ...;
      SocketChannelConfig cfg = (SocketChannelConfig) ch.getConfig();
      cfg.setAllocator(PooledByteBufAllocator.DEFAULT);
   ```

   在ChannelConfig的默认实现`DefaultChannelConfig`中，`setOption`方法内部还是通过判断ChanneOption方法来选择对应的方法设置的。

   ```java
   public class DefaultChannelConfig implements ChannelConfig {
   ....
   public <T> boolean setOption(ChannelOption<T> option, T value) {
       validate(option, value);
    
       if (option == CONNECT_TIMEOUT_MILLIS) {//判断ChannelOption类型，再调用对应的方法
           setConnectTimeoutMillis((Integer) value);
       } else if (option == MAX_MESSAGES_PER_READ) {
           setMaxMessagesPerRead((Integer) value);
       } else if (option == WRITE_SPIN_COUNT) {
           setWriteSpinCount((Integer) value);
       } else if (option == ALLOCATOR) {
           setAllocator((ByteBufAllocator) value);
       } else if (option == RCVBUF_ALLOCATOR) {
           setRecvByteBufAllocator((RecvByteBufAllocator) value);
       } else if (option == AUTO_READ) {
           setAutoRead((Boolean) value);
       } else if (option == AUTO_CLOSE) {
           setAutoClose((Boolean) value);
       } else if (option == WRITE_BUFFER_HIGH_WATER_MARK) {
           setWriteBufferHighWaterMark((Integer) value);
       } else if (option == WRITE_BUFFER_LOW_WATER_MARK) {
           setWriteBufferLowWaterMark((Integer) value);
       } else if (option == MESSAGE_SIZE_ESTIMATOR) {
           setMessageSizeEstimator((MessageSizeEstimator) value);
       } else {//如果不是上述类型，返回false，表示不支持此ChannelOpiton
           return false;
       }
       return true;
   }
   ....
   }
   ```

   

3. **ChannelOption**

   **ChannelConfig接口中定义的公共ChannelOption，SocketChannelConfig 和ServerSocketChannelConfig 支持的ChannelOption基本上都是TCP连接参数相关的**，基本上每一个都对应`java.net.StandardSocketOptions` 定义的一个标准TCP参数

   - **ChannelOption.SO_KEEPALIVE**-->StandardSocketOptions.SO_KEEPALIVE

     是否启用心跳机制,默认false。

   - **ChannelOption.SO_REUSEADDR-->**StandardSocketOptions.SO_REUSEADDR

     是否重用处于TIME_WAIT状态的地址。默认为false。

   - **ChannelOption.SO_LINGER-->**StandardSocketOptions.SO_LINGER

     优雅地关闭套接字，或者立刻关闭。

   - **ChannelOption.SO_SNDBUF-->**StandardSocketOptions.SO_SNDBUF

     发送缓冲区的大小设置，默认为8K。

   - **ChannelOption.SO_RCVBUF-->**StandardSocketOptions.SO_RCVBUF

     接收缓冲区大小设置，默认为8K。该属性既可以在ServerSocket实例中设置，也可以在Socket实例中设置。

   - ChannelOption.TCP_NODELAY-->**StandardSocketOptions.TCP_NODELAY

     是否一有数据就马上发送。TCP_NODELAY选项，就是用于启用或关于Nagle算法。如果要求高实时性，有数据发送时就马上发送，就将该选项设置为true关闭Nagle算法；如果要减少发送次数减少网络交互，就设置为false等累积一定大小后再发送。默认为false。

   - **ChannelOption.SO_BACKLOG**

     BACKLOG用于构造服务端套接字ServerSocket对象，标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度。如果未设置或所设置的值小于1，Java将使用默认值50。

   > 理解了这些参数之后，还有一点需要注意的是，由于Netty只是对java网络编程API的一层封装，因此表面上NioSocketChannelConfig、NioServerSocketChannelConfig 包含的参数分别设置给了NioSocketChannel，NioServerSocketChannel。但事实上这些参数必须要设置给java原生的Socket对象才能生效。

4. **ChannelHander**

   在nio编程中，我们经常需要对channel的输入和输出事件进行处理，Netty抽象出一个ChannelHandler概念，专门用于处理此类事件。

   因为IO事件分为输入和输出，因此ChannelHandler又具体的分为ChannelInboundHandler和ChannelOutboundHandler ，分别用于某个阶段输入输出事件的处理。
   ![netty-channelHandler](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/netty/netty-channelHandler.png)

   ChannelHandlerAdapter、ChannelInboundHandlerAdapter 、ChannelOutboundHandlerAdapter是Netty提供的适配器，对于输入输出事件，只需要继承适配器，重写感兴趣的方法即可。

   在处理channel的IO事件时，我们通常会分成几个阶段。以读取数据为例，通常我们的处理顺序是：
   `处理半包或者粘包问题-->数据的解码(或者说是反序列化)-->数据的业务处理`

   可以看到不同的阶段要执行不同的功能，因此通常我们会编写多个ChannelHandler，来实现不同的功能。而且多个ChannelHandler之间的顺序不能颠倒，例如我们必须先处理粘包解包问题，之后才能进行数据的业务处理。

5. #### ChannelPipeline

   Netty中通过ChannelPipeline来保证ChannelHandler之间的处理顺序。每一个Channel对象创建的时候，都会自动创建一个关联的ChannelPipeline对象，我们可以通过io.netty.channel.Channel对象的pipeline()方法获取这个对象实例。

   ChannelPipeline 的具体的创建过程定义AbstractChannel类的构造方法中：

   ```java
   public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
   ....
   private final DefaultChannelPipeline pipeline;
   ....
   protected AbstractChannel(Channel parent) {
       this.parent = parent;
       id = newId();
       unsafe = newUnsafe();
       pipeline = newChannelPipeline();//创建默认的pipeline
   }
   ....
   protected DefaultChannelPipeline newChannelPipeline() {
       return new DefaultChannelPipeline(this);
   }
   ....
   @Override
       public ChannelPipeline pipeline() {//实现Chnannel定义的pipeline方法，返回pipeline实例
           return pipeline;
       }
   }
   
   ```

   因为ChannelPipleLine的创建是定义在AbstractChannel的构造方法中的，而每个Channel只会被创建一次，只会调用一次构造方法，因此每个Channel实例唯一对应一个ChannelPipleLine 实例。

   从上述代码中，我们可以看到ChannelPipleLine的具体创建过程实际上是通过return new DefaultChannelPipeline(this);实现的。DefaultChannelPipeline是ChannelPipeline的默认实现类。

   >注意：
   >1、默认情况下，一个ChannelPipeline实例中，同一个类型ChannelHandler只能被添加一次，如果添加多次，则会抛出异常，具体参见io.netty.channel.DefaultChannelPipeline#checkMultiplicity。如果需要多次添加同一个类型的ChannelHandler的话，则需要在该ChannelHandler实现类上添加@Sharable注解。
   >
   >2、在ChannelPipeline中，每一个ChannelHandler都是有一个名字的，而且名字必须的是唯一的，如果名字重复了，则会抛出异常，参见io.netty.channel.DefaultChannelPipeline#checkDuplicateName。
   >
   >3、如果添加ChannelHanler的时候没有显示的指定名字，则会按照规则其起一个默认的名字。具体规则如下，如果ChannelPipeline中只有某种类型的handler实例只有一个,如XXXHandler,YYYHandler，则其名字分别为XXXHandler#0，YYYHandler#0，如果同一类型的Handler有多个实例，则每次之后的编号加1。具体可参见io.netty.channel.DefaultChannelPipeline#generateName方法。

6. **ChannelHandlerContext**
   前面提到可以通过ChannelPipeline的添加方法，按照顺序添加ChannelHandler，并在之后按照顺序进行调用。事实上，每个ChannelHandler会先被封装成ChannelHandlerContext。之后再添加进ChannelPipeline中。

   以DefaultChannelPipeline的addLast方法为例，如果查看源码，最终会定位到以下方法：

   DefaultChannelPipeline#addLast(EventExecutorGroup, String,ChannelHandler)

   ```java
   @Override
   public ChannelPipeline addLast(EventExecutorGroup group, final String name, ChannelHandler handler) {
       synchronized (this) {
           checkDuplicateName(name);//check这种类型的handler实例是否允许被添加多次
          //将handler包装成一个DefaultChannelHandlerContext类
           AbstractChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, group, name, handler);
           addLast0(name, newCtx);//维护AbstractChannelHandlerContext的先后关系
       }
   
       return this;
   }
   
   ```

   可以看到的确是先将ChannelHandler当做参数构建成一个DefaultChannelHandlerContext实例之后，再调用addLast0方法维护ChannelHandlerContext的先后关系，从而确定了ChannelHandler的先后关系。

   ![ChannelHandlerContext](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/netty/ChannelHandlerContext.png)

   ChannelPipeline的默认实现类是DefaultChannelPipeline，ChannelHandlerContext的默认实现类是DefaultChannelHandlerContext。

   DefaultChannelPipeline内部是通过一个双向链表记录ChannelHandler的先后关系，而双向链表的节点是AbstractChannelHandlerContext类。
   以下是AbstractChannelHandlerContext类的部分源码(双向链表节点)：

   ```java
   abstract class AbstractChannelHandlerContext extends DefaultAttributeMap
           implements ChannelHandlerContext, ResourceLeakHint {
   ...
   volatile AbstractChannelHandlerContext next;//当前节点的上一个节点
   volatile AbstractChannelHandlerContext prev;//当前节点的下一个节点
   ...
   }
   
   ```

   DefaultChannelPipeline内部通过两个哨兵节点HeadContext和TailContext作为链表的开始和结束，熟悉双向链表数据结构的同学，肯定知道，设置哨兵可以在移除节点的时候，不需要判断是否是最后一个节点。相关源码如下：

   ```java
   public class DefaultChannelPipeline implements ChannelPipeline {
   ...
   private static final String HEAD_NAME = generateName0(HeadContext.class);
   private static final String TAIL_NAME = generateName0(TailContext.class);
   ...
   final AbstractChannelHandlerContext head;//双向链表的头元素
   final AbstractChannelHandlerContext tail;//双向列表的尾部元素
   
   private final Channel channel;
   ....
   protected DefaultChannelPipeline(Channel channel) {
       this.channel = ObjectUtil.checkNotNull(channel, "channel");
        ....
       tail = new TailContext(this);//创建双向链表头部元素实例
       head = new HeadContext(this);//创建双向链表的尾部元素实例
       //设置链表关系
       head.next = tail;
       tail.prev = head;
   }
   ....
   ....
   private void addLast0(AbstractChannelHandlerContext newCtx) {
      //设置ChannelHandler的先后顺序关系
       AbstractChannelHandlerContext prev = tail.prev;
       newCtx.prev = prev;
       newCtx.next = tail;
       prev.next = newCtx;
       tail.prev = newCtx;
      }
    }
   }
   ```

   

7. ##### ChannelHander、ChannelPipeline、ChannelHandlerContext的联合工作过程

   DefaultChannelPipeline是将ChannelHander包装成AbstractChannelHandlerContext类之后，再添加到链表结构中的，从而实现handler的级联调用。	

   ChannelInboundHandler 接口定义的9个方法：

   ```java
   public interface ChannelInboundHandler extends ChannelHandler {
       void channelRegistered(ChannelHandlerContext ctx) throws Exception;
       void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
       void channelActive(ChannelHandlerContext ctx) throws Exception;
       void channelInactive(ChannelHandlerContext ctx) throws Exception;
       void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;
       void channelReadComplete(ChannelHandlerContext ctx) throws Exception;
       void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;
       void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;
       void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
   }
   ```

   而在ChannelPipeline和ChannelHandlerContext中，都定义了相同的9个以fire开头的方法，如下所示

   ![channelpipeline-ChannelHandlerContext](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/netty/channelpipeline-ChannelHandlerContext.png)

   可以发现这两个接口定义的9个方法与ChannelInboundHandler定义的9个方法是一一对应的，只是在定义每个方法的时候，在前面加了1个fire。

   ######1. 调用顺序
   - 先是ChannelPipeline中的fireXXX方法被调用

   - ChannelPipeline中的fireXXX方法接着调用ChannelPipeline维护的ChannelHandlerContext链表中的第一个节点即HeadContext 的fireXXX方法

   - ChannelHandlerContext 中的fireXXX方法调用ChannelHandler中对应的XXX方法。由于可能存在多个ChannelHandler，因此每个ChannelHandler的xxx方法又要负责调用下一个ChannelHandlerContext的fireXXX方法，直到整个调用链完成

   ###### 2. ChannelHandler中各方法调用时机

   1.  fireChannelRegistered() 和fireChannelActive()是在Channel注册到EventLoop中时调用的，只会被调用一次

      io.netty.channel.AbstractChannel.AbstractUnsafe#register0

      ```java
      private void register0(ChannelPromise promise) {
          try {
              ...
              doRegister();//注册通道到EventLoop中
              registered = true;
              safeSetSuccess(promise);
              pipeline.fireChannelRegistered();//注册成功，调用fireChannelRegistered()
              if (isActive()) {
                  pipeline.fireChannelActive();//如果激活，调用fireChannelActive()
              }
          } catch (Throwable t) {
              ....
          }
      }
      ```

      类似的，当取消注册时候fireChannelInactive()、fireChannelUnregistered()会被调用

   2. fireChannelRead(Object msg) 和fireChannelReadComplete()在有数据需要读取的情况下会被触发，可能会被触发多次

      io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read

      ```java
      @Override
      public void read() {
          ....
          try {
              int totalReadAmount = 0;
              boolean readPendingReset = false;
              do {
                  ....
                  pipeline.fireChannelRead(byteBuf);//有数据要读取，调用fireChannelRead
                  ....
              } while (++ messages < maxMessagesPerRead);
      
              pipeline.fireChannelReadComplete();//数据读取完成，调用fireChannelReadComplete()
              ....
          } catch (Throwable t) {
              handleReadException(pipeline, byteBuf, t, close);
          } finally {
              ....
          }
      }
      ```

      

   3. fireExceptionCaught()方法，在读取数据出错的情况下，会被调用

      在上述代码片段中，有一个handleReadException方法，表示如果读取数据出错的处理逻辑，其内部会调用fireExceptionCaught()

      io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#handleReadException

      ```java
      private void handleReadException(ChannelPipeline pipeline,
                              ByteBuf byteBuf, Throwable cause, boolean close) {
          ....
          pipeline.fireExceptionCaught(cause);//出现异常时，调用fireExceptionCaught
          if (close || cause instanceof IOException) {
              closeOnRead(pipeline);
          }
      }
      ```

      

   4. fireUserEventTriggered(Object event) 当正在读取数据的时候，如果连接关闭，调用此方法

      上述代码片段在处理异常的时候，会判断异常类型是否是IOException或者连接是否关闭，如果是，则调用closeOnRead方法，这个方法内部会调用 fireUserEventTriggered(Object event)

      io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#closeOnRead

      ```java
      private void closeOnRead(ChannelPipeline pipeline) {
          SelectionKey key = selectionKey();
          setInputShutdown();
          if (isOpen()) {
              if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
                  key.interestOps(key.interestOps() & ~readInterestOp);
                  pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);//调用fireUserEventTriggered方法
              } else {
                  close(voidPromise());
              }
          }
      }
      ```

      

   5. fireChannelWritabilityChanged()方法，当有数据需要输出的时候被调用

      io.netty.channel.ChannelOutboundBuffer#incrementPendingOutboundBytes

      ```
      void incrementPendingOutboundBytes(int size) {
          ...
          long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);
          if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {
              if (WRITABLE_UPDATER.compareAndSet(this, 1, 0)) {
                  channel.pipeline().fireChannelWritabilityChanged();//需要输出数据，调用fireChannelWritabilityChanged()
              }
          }
      }
      ```



##### TCP粘包、拆包与通信协议

在TCP编程中，通常Sever端与Client通信时的消息都有着固定的消息格式，称之为协议(protocol)，协议了就是定义了数据通信的格式。主要是为了解决TCP编程中的粘包和半包问题。

由于TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的。

UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。

由于TCP无消息保护边界, 需要在消息接收端处理消息边界问题，也就是我们所说的粘包、拆包问题；而UDP通信则不需要考虑此问题。

粘包、拆包发生原因:

- socket缓冲区与滑动窗口
- MSS/MTU限制
- Nagle算法



#####Netty 编解码

我们提到TCP的粘包、拆包问题，可以通过自定义通信协议的方式来解决。通信协议就是通信双方约定好的数据格式，发送方按照这个数据格式来发送，接受方按照这个格式来解析。典型的协议包括：定长协议、特殊字符分隔符协议、报文头指定Length等。在确定了使用什么通信协议的情况下，发送方和接收方要完成的工作不同：

**编码：**发送方要将发送的二进制数据转换成协议规定的格式的二进制数据流，称之为编码(encode)，编码功能由编码器(encoder)完成。

**解码：**接收方需要根据协议的格式，对二进制数据进行解析，称之为解码(decode)，解码功能由解码器(decoder)完成。

**编解码：**如果有一种组件，既能编码，又能解码，则称之为编码解码器(codec)。这种组件在发送方和接收方都可以使用。

Netty提供了一套完善的编解码框架，不论是公有协议/私有协议，我们都可以在这个框架的基础上，非常容易的实现相应的编码/解码器。输入的数据是在`ChannelInboundHandler`中处理的，数据输出是在`ChannelOutboundHandler`中处理的。因此编码器/解码器实际上是这两个接口的特殊实现类，不过它们的作用仅仅是编码/解码。

![编码解码器](/Users/longhairen/Documents/idea_workspace/my-project/sources/source-network/pic/netty/编码解码器.png)

1. 解码器

   对于解码器，Netty中主要提供了抽象基类`ByteToMessageDecoder`和`MessageToMessageDecoder`

   1.1  **抽象类ByteToMessageDecoder**

   用于将接收到的二进制数据(Byte)解码，得到完整的请求报文(Message)。

   通常，ByteToMessageDecoder解码后内容会得到一个ByteBuf实例列表，每个ByteBuf实例都包含了一个完整的报文信息。你可以直接把这些ByteBuf实例直接交给之后的ChannelInboundHandler处理，或者将这些包含了完整报文信息的ByteBuf实例解析封装到不同的Java对象实例后，再交其处理。不管哪一种情况，之后的ChannelInboundHandler在处理时不需要在考虑粘包、拆包问题。

   ByteToMessageDecoder提供的一些常见的实现类：

   - **FixedLengthFrameDecoder：**定长协议解码器，我们可以指定固定的字节数算一个完整的报文
   - **LineBasedFrameDecoder：**行分隔符解码器，遇到\n或者\r\n，则认为是一个完整的报文
   - **DelimiterBasedFrameDecoder：**分隔符解码器，与LineBasedFrameDecoder类似，只不过分隔符可以自己指定
   - **LengthFieldBasedFrameDecoder：**长度编码解码器，将报文划分为报文头/报文体，根据报文头中的Length字段确定报文体的长度，因此报文提的长度是可变的
   - **JsonObjectDecoder：**json格式解码器，当检测到匹配数量的"{" 、”}”或”[””]”时，则认为是一个完整的json对象或者json数组。

   这些实现类，都只是将接收到的二进制数据，解码成包含完整报文信息的ByteBuf实例后，就直接交给了之后的ChannelInboundHandler处理。之所以不将ByteBuf中的信息封装到Java对象中，道理很简单，Netty根本不知道开发者想封装到什么对象中，甚至不知道报文中的具体内容是什么，因此不如直接把包含了完整报文信息的ByteBuf实例，交给开发人员来自己解析封装。

   我们也可以自定义ByteToMessageDecoder，此时需要覆盖ByteToMessageDecoder的`decode`方法：

   ```java
   protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
   ```

   参数的作用如下：

   - in：需要解码的二进制数据。
   - List<Object> out：解码后的有效报文列表，我们需要将解码后的报文添加到这个List中。之所以使用一个List表示，是因为考虑到粘包问题，因此入参的in中可能包含多个有效报文。当然，也有可能发生了拆包，in中包含的数据还不足以构成一个有效报文，此时不往List中添加元素即可。

2. 编码器

