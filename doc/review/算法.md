https://labuladong.gitbook.io/algo/

> 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。数据结构是工具，算法是通过合适的工具解决特定问题的方法

#### 技巧库

数组：二分查找、快慢指针、左右指针、滑动窗口、前缀和数组、差分数组



#### 数据结构

1. 数据结构的存储方式

   - **数组**由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
   - **链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

2. 数据结构的基本操作

   对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。**数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改**。

   从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。线性就是 for/while 迭代为代表，非线性就是递归为代表。

   数组遍历框架，典型的线性迭代结构：

   ```java
   void traverse(int[] arr) {
       for (int i = 0; i < arr.length; i++) {
           // 迭代访问 arr[i]
       }
   }
   ```

   链表遍历框架，兼具迭代和递归结构：

   ```java
   /* 基本的单链表节点 */
   class ListNode {
       int val;
       ListNode next;
   }
   
   
   void traverse(ListNode head) {
       for (ListNode p = head; p != null; p = p.next) {
           // 迭代访问 p.val
       }
   }
   
   
   void traverse(ListNode head) {
       // 递归访问 head.val
       traverse(head.next);
   }
   ```

   二叉树遍历框架，典型的非线性递归遍历结构：

   ```java
   /* 基本的二叉树节点 */
   class TreeNode {
       int val;
       TreeNode left, right;
   }
   
   
   void traverse(TreeNode root) {
       traverse(root.left);
       traverse(root.right);
   }
   ```



#### 二分查找

思路很简单，细节是魔鬼，二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 <= 还是 <

算法框架：

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```





#### 回溯算法

回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：

1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，无法再做选择的条件。

算法框架：

```python
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```



> 动态规划与回溯算法
>
> 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。



#### BFS

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。

算法框架：

```python
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```



#### 动态规划

1. 递归+记忆化 ——> 递推
2. 状态定义：dp[n]
3. 状态转移方程：dp[n] = best(dp[n-1],dp[n-2]...)
4. 最优子结构



首先，动态规划问题的一般形式就是求最值，求解动态规划的核心问题是穷举。动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。列出**正确的「状态转移方程」**，才能正确地穷举。

重叠子问题、最优子结构、状态转移方程就是动态规划三要素，过程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

框架：

```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

**递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间**。



#### 滑动窗口





























