### Question

- spring循环依赖
- 自增索引优势（性能-页分裂，空间-辅助索引）
- zk与redis选主区别
- spring如何管理bean
- threadlocal 子线程引用
- sycn优化，锁升级
- 栈的结构与执行过程，为什么选用栈
- 删除空表会不会加锁
- mybatis sqlsession，默认分页缺点
- hashmap为什么扩展2n
- mysql减少回表优化（建立联合索引，使用覆盖索引，索引下推减少回表次数）
- mysql rr隔离级别如何解决可重复读于幻读
- 高qps下频繁year GC 如何定位和保障稳定性
- RPC 核心需要哪些模块
- 缓存与DB一致性保障
- ConcurrentHashMap HashMap 扩容的时候加入数据
- Jdk1.8 为什么废弃了永久代
- Redis 热点数据处理，为什么固定哈希槽，
- rocketmq 



算法：
链表找倒数第k个数
二叉树找公共祖先

---

1. 两个进程的变量的地址相同，它们之间的写操作有相互的影响吗

   不影响，物理地址和逻辑地址，每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到

2. 进程间通信的方式

   - 管道/匿名管道（pipe）
   - 有名管道（FIFO）
   - 信号（signal）
   - 消息(Message)队列
   - 共享内存(share memory)

   - 信号量(semaphore)

   - 套接字(socket)

3. Mysql如何保证一致性

   数据库通过原子性、隔离性、持久性来保证一致性，原子性（undo log）、持久性（redo log）、隔离性（锁和MVCC）

4. 如何解决引用计数的循环引用问题

   使用强弱引用来解决循环引用问题，注意野指针问题

5. HashMap 扩容做了哪些优化

   - 扩容2的幂次，使hash算法的结果均匀分布，减少碰撞，扩容时元素要么在原来位置要么在原来位置移动2次幂的位置，不用重新hash

6. as-if-serial ：不管怎么重排序（编译器和处理器），（单线程）程序的执行结果不会改变

7. 对Java内存模型的理解

   JMM是一种抽象规范，定义了程序中各个变量的访问方式，每个线程在创建时JVM都会为线程创建一个工作内存，线程对变量的操作都是在工作内存中完成的，但是所有共享变量都是存放在主内存的，所以线程需要将变量从主内存拷贝到自己的工作内存，操作完之后再将变量同步回主内存。JMM是为了解决多线程并发环境下的线程安全问题，解决程序执行的原子性、有序性、可见性。

   程序员角度显式使用的规则：synchronized、volatile、lock、final，隐式规则：happens-before规则规定了有序性

8. ConcurrentHashMap

   - put 过程

   ```text
   1，懒加载，未初始化则初始化table
   2，hash，hashcode再散列，并计算下标
   3，无碰撞，通过CAS插入
   4，有碰撞
   　　4.1、如果正在扩容，协助其它线程去扩容
   　　4.2、如果当前key和当前桶位置key相等则替换value
   　　4.3、锁住当前桶位置，如果是链表，插入链表
   　　4.4、如果是红黑树，插入红黑树
   　　4.5、如果链表长度超过8，树化
   　　4.6，如果key已经存在，覆盖旧值
   5，需要扩容，则扩容
   ```

   - 并发时的扩容

   ```
   情况一：访问蓝色桶，即未扩容的桶。正常执行put逻辑。
   情况二：访问绿色桶，即正扩容的桶。因为线程1持有Synchronized锁，线程3将一直自旋，等待扩容结束。
   情况三：访问橘色桶，即已扩容的桶。因为已扩容的桶，在oldTab中是fwd节点，hash = -1 = MOVED，所以线程3执行帮助扩容的逻辑。等待扩容完成，线程3继续完成put逻辑。
   ```

   	- 并发时的get

   ```
   情况一：访问蓝色号桶，即未扩容的桶。该桶还未进行扩容，所以在桶中找到对应元素，返回。
   情况二：访问绿色桶，即正在扩容的桶。该桶正在扩容，在扩容过程中，线程1持有Synchronized锁，线程2只能自旋等待。
   情况三：访问橘色桶，该桶已扩容的桶。该桶已扩容，oldTab中是fwd节点，hash=-1，所以执行fwd节点的find逻辑，fwd节点持有newTab(nextTable)，所以线程2去newTab中查找对应元素，返回。
   ```

   - 并发扩容

   ```
   1. 单线程新建nextTable，新容量一般为原table容量的两倍。
   2. 每个线程想增/删元素时，如果访问的桶是ForwardingNode节点，则表明当前正处于扩容状态，协助一起扩容完成后再完成相应的数据更改操作。
   3. 扩容时将原table的所有桶倒序分配，每个线程每次最小分配16个桶，防止资源竞争导致的效率下降。单个桶内元素的迁移是加锁的，但桶范围处理分配可以多线程，在没有迁移完成所有桶之前每个线程需要重复获取迁移桶范围，直至所有桶迁移完成。
   一个旧桶内的数据迁移完成但不是所有桶都迁移完成时，查询数据委托给ForwardingNode结点查询nextTable完成（这个后面看find()分析）。
   4. 迁移过程中sizeCtl用于记录参与扩容线程的数量，全部迁移完成后sizeCtl更新为新table容量的0.75倍。
   ```

   - sizeCtl 属性在各个阶段的作用

   ```
   1. 新建而未初始化时：sizeCtl 用于记录初始容量大小，仅用于记录集合在实际创建时应该使用的大小的作用 
   2. 初始化过程中：将 sizeCtl 值设置为 -1 表示集合正在初始化中，其他线程发现该值为 -1 时会让出CPU资源以便初始化操作尽快完成 
   3. 初始化完成：sizeCtl 用于记录当前集合的负载容量值，也就是触发集合扩容的极限值 
   4. 正在扩容时：sizeCtl 用于记录当前扩容的并发线程数情况，此时 sizeCtl 的值为：((rs << RESIZE_STAMP_SHIFT) + 2) + (正在扩容的线程数) ，并且该状态下 sizeCtl < 0
   ```

   - size 计算流程

   ```
   size 计算实际发生在 put，remove 改变集合元素的操作之中
   - 没有竞争发生，向 baseCount 累加计数
   - 有竞争发生，新建 counterCells，向其中的一个 cell 累加计数
   	- counterCells 初始有两个 cell
   	- 如果计数竞争比较激烈，会创建新的 cell 来累加计数
   ```

   - ConcurrentHashMap 扩容时机
     - 调用put方法新增节点时，在结尾会调用addCount方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发transfer方法，重新调整节点的位置。
     - 如果新增节点之后，所在**链表的元素个数达到了阈值 8**，并且size < 64时会进行扩容
     - putAll批量插入或者插入节点后发现链表长度达到8个或以上，但数组长度为64以下时触发的扩容

9. 线程池

   - 核心参数、执行任务流程
   - 线程回收（获取任务时判断超时、没有任务时从线程列表移除，通过GC回收）
   - 线程数量设置（根据具体业务）、动态参数

10. Synchronized 锁

    synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的。先了解两个概念，对象头的mark word中有个锁标志位，根据不同场景标志位随之变化，加锁也随之变化；monitor是一种同步机制，通常是一个对象，每个线程都有一个monitor record列表，同时还有一个全局可用列表，每一个被锁住的对象都会和一个monitor关联，同时monitor中拥有占有线程的ID，monitor依赖操作系统的互斥锁实现线程同步。

    - 无锁：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
    - 偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
    - 轻量级锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
    - 重量级锁：当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

11. AQS和Reentrantlock

    通过一个volatile修饰的state的成员变量表示同步状态，通过内置的FIFO队列完成资源获取的排队工作，通过CAS完成对state值的修改。例如独占模式下的非公平锁，线程A获取锁，通过CAS将state修改为1，如果修改成功则将锁的owner线程设置成自己，返回获取锁成功，不然将当前线程包装成一个node加入内部队列中，然后自循的调用队列中的节点获取锁资源

12. GC 

    明确优化目标→优化→跟踪优化结果

13. mysql 不走索引情况

    - 索引列参与计算
    - 索引列使用了函数
    - 索引列使用了like %
    - 字符串列与数字直接比较
    - 尽量避免 OR 操作

14. mysql 锁

    - innodb 锁分类

      - Record Locks(行锁)：行锁，顾名思义，是加在`索引行`(对！是索引行！不是数据行！)上的锁。
      - Gap Locks(间隙锁)：间隙锁，它会锁住两个索引之间的区域（开区间）。
      - Next-Key Locks(间隙锁)：也叫间隙锁，它是Record Lock + Gap Lock形成的一个闭区间锁。

    - 什么时候会加锁？

      在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:

      - select: 即最常用的查询，是不加任何锁的
      - select ... lock in share mode: 会加共享锁(Shared Locks)
      - select ... for update: 会加排它锁

    - 从准备更新一条数据到事务的提交的流程描述

      - 首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中
      - 在数据被缓存到缓存池的同时，会写入 undo log 日志文件
      - 更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中
      - 完成以后就可以提交事务，在提交的同时会做以下三件事
        - 将redo log buffer中的数据刷入到 redo log 文件中
        - 将本次操作记录写入到 bin log文件中
        - 将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记

    - Mysql MVCC如何实现

      >- 当前读：select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
      >- 快照读：不加锁的select操作就是快照读，快照读是不加锁的非阻塞读，可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

      MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 **3个隐式字段**，**undo日志** ，**Read View** 来实现的。每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID（最近修改的事务ID）,DB_ROLL_PTR（回滚指针）,DB_ROW_ID（隐藏主键）等字段，用于配合undo日志，指向上一个旧版本。

      read view 读视图，当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。



---

1. Spring 循环依赖，通过 Spring的三级缓存解决

   - 构造器注入循环依赖：此种循环依赖方式是无法解决的，Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是`已经实例化`，但还没初始化的状态。
   - field属性注入（setter方法注入）循环依赖
   - prototype field属性注入循环依赖

2. Spring 三级缓存

   - singletonObjects：用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用
   - earlySingletonObjects：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖
   - singletonFactories：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖
   - singletonsCurrentlyInCreation：表示bean创建过程中都会在里面呆着，在Bean开始创建时放值，创建完成时会将其移出
   - alreadyCreated：当这个Bean被创建完成后，会标记为这个，至少被创建了一次的  都会放进这里

   https://cloud.tencent.com/developer/article/1497692

3. Spring bean 的生命周期

   doCreateBean 调用创建bean方法

   createBeanInstance 实例化bean，调用构造方法

   populateBean 填充属性

   BeanNameAware.setBeanName 

   BeanFactoryAware.setBeanFactory

   BeanPostProcesser.postProcessBeforeInitialization bean 后置处理器预处理

   InitializingBean.afterPropertiesSet 

   Init-method

   BeanPostProcesser.postProcessAfterInitialization

   可用的Spring bean

   DisposableBean.distroy()

4. mysql用自增主键的好处

   - 从空间方面考虑，int 或者bigint占用空间小
   - 查询性能方面，数据类型越小或平均每条记录所占用的空间越小，那么在一个页中，可以放的数据条数就越多。这可以有效的减少磁盘I/O
   - 插入性能方面，MYSQL的索引树是按索引列进行排序的，而如果我们用无序的uuid直接插入数据的话很可能会破坏这个平衡，而自增id则可以避免破坏这个平衡。页分裂时可能要将一部分数据移动到新页中，使用自增id，因为本来就是有序的，直接在新页往下写就是了。

5. Jdk1.8 为什么废弃了永久代

   有经验的同学会发现，对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。

   而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。

   1、字符串存在永久代中，容易出现性能问题和内存溢出。

   2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

   3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

6. 双亲委派机制的作用
   1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
   2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。

   
   
7. 进程间通信的方式

   - 管道/匿名管道（pipe）：管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。只能用于父子、兄弟进程之间
     - 实质：管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
     - 局限：单向数据流，只能用于亲缘关系的进程，管道缓冲区有限
   - 有名管道（FIFO）：以文件形式存在文件系统，可以用于不同进程间通信
   - 信号（signal）
     - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
     - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
     - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。
   - 消息(Message)队列
        - 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示
        - 只有内核重启或者显示删除才能被删除
   - 共享内存(share memory)
     - 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
     - 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
     - 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

   - 信号量(semaphore)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
     为了获得共享资源，进程需要执行下列操作：
     （1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
     （2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
     （3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。

   - 套接字(socket)
     套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。

#### 介绍

一直在上海从事Java后端研发工作，19年初来的饿了么一直到现在，现在在饿了么物流研发部，担任物流代理商基础服务组的小leader，虚线带了三个人，主要负责骑手组织化管理、运力精细化管控、提供履约运力服务等三块业务。现在我是五个业务服务的owner，其中有两个是物流关键链路基础服务，这两个服务为履约配送提供运力相关的数据，高峰时段达到65k 以上的qps，平均响应时间在2ms，99线在40ms内，任何波动都会影响上层的履约配送，所以这两个服务对稳定性和性能要求极高，我接手之后在稳定性上做了很多事情，期间没有出现过一次冒烟和事故。即时配送是一个强管理的业务，需要一线小二去管理和抓质量，由于历史原因，物流的一线管理权限一直很乱，所以去年我牵头推动业务一起搭建了物流组织权限磐石项目，独立完成整体架构设计和80%的coding，解决了物流一线管理与运营的痛点，为上层业务产品提供基础权限能力。此外我还负责小组内的产品需求评审、规划迭代排期、技术方案评审、code review等工作，我80%的精力还是在设计和coding上面，对代码有一定的追求，注重规范，具备核心系统架构设计能力，也具有一定的产品设计能力。我还是很喜欢搞技术的，Java基础、mysql、redis等常用技术还是比较熟悉的。

首先我来介绍一下整体的一个业务背景，我们做即时配送关键点在于物理位置与运力关系的维护，首先通过经纬度将物理位置划分成一块一块的网格，然后对这些网格进行招标，招募配送代理商，代理商中标之后在这个网格之上会建立配送站点，然后招募骑手，在物流端搭建运力的过程中，B端的小二也会同时去谈商家，商家入驻之后需要购买我们的运力服务。这这个过程中我们的角色就是划分物理网格、网格与运力、商家与运力的关系，配送代理商、配送站点、骑手等数据就是所谓的运力数据。当C端有用户在这个商家下单时，商家接单之后出餐选择配送生成运单，这个时候我们就需要提供这个商家所在网格有哪些配送代理商，配送代理商下面的配送站点，站点里面的可用骑手，提供这些运力数据给履约调度使用，最终单分到骑手，骑手完成配送。

这些运力的组织和管理需要一线小二来完成，每个小二负责哪些区域，一线的汇报关系等，所以针对物流一线实际的汇报关系，我搭建了一个棵业务组织树，上面体现了整个物流关系相关的区域、角色、人员关系，然后又抽象出一颗物流资源树，城市、配送代理商、配送站点、网格等



新建联合索引，缩减返回字段，满足覆盖索引和索引下推减少回表，

- 分离普通业务与履约核心链路资源，DB和Redis，聚拢撒布在各个应用的主链路接口到两个核心应用
- 分离履约主链路与普通业务的接口和集群
- 支持多级缓存，本地缓存和集中式缓存，通过 DB binlog 和 MQ 消息保证 DB与缓存的一致性
- 线上细分监控报警，异常、服务接口RT、中间件、db、GC等方面的关键指标监控
- 工程规约，编译时规约检查（统一格式化、阿里开发规约）、google errorprone静态检查
- 严格把关服务迭代流程，需求评审、技术方案评审、code review、业务监控，做到可灰度、可观测、可回滚


难点
稳定性：
1. 高峰时单机经常出现大量NoAvailableThreadException，原因是redis.getResource时间过长，导致高峰时段服务线程被占满，最终查出来是因为redis 的testOnBorrow 和testOnReturn 设置为true了，导致获取redis连接时间增多，在高峰时大批流量进来导致占满了服务线程
2. 一次countDownLatch 导致的jvm 宕机，查看监控有个响应时间达到了十几二十分钟，CPU飙到140，内存爆满，查看thread dump 文件 发现大量线程卡在countDownLatch，翻看源码发现源码中countDownLatch的countDown 的调用没有放在finaly里面，前面出席异常导致很多线程等待在await里，累计多了内存爆满最终导致内核kill了jvm 
3. 大分页步长导致的问题



挑战
性能调优：拆分sql，基本单表查询，
技术推动项目：


规划
