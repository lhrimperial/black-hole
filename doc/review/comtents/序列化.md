### 序列化

#### 一、什么是Java序列化？

- 序列化：把Java对象转换为字节序列的过程
- 反序列：把字节序列恢复为Java对象的过程



#### 二、为什么需要序列化？

Java对象是运行在JVM的堆内存中的，如果JVM停止后，它的生命也就戛然而止，如果想在JVM停止后，把这些对象保存到磁盘或者通过网络传输到另一远程机器，怎么办呢？磁盘这些硬件可不认识Java对象，它们只认识二进制这些机器语言，所以我们就要把这些对象转化为字节数组，这个过程就是序列化。



#### 三、序列化用途

序列化使得对象可以脱离程序运行而独立存在，它主要有两种用途：

-  序列化机制可以让对象地保存到硬盘上，减轻内存压力的同时，也起了持久化的作用
- 序列化机制让Java对象在网络传输不再是天方夜谭



#### 四、Java序列化

##### 常用序列化API

1. Serializable 接口

   Serializable接口是一个标记接口，没有方法或字段。一旦实现了此接口，就标志该类的对象就是可序列化的。

2. Externalizable 接口

   Externalizable继承了Serializable接口，还定义了两个抽象方法：writeExternal()和readExternal()，如果开发人员使用Externalizable来实现序列化和反序列化，需要重写writeExternal()和readExternal()方法

3. java.io.ObjectOutputStream类

   表示对象输出流，它的writeObject(Object obj)方法可以对指定obj对象参数进行序列化，再把得到的字节序列写到一个目标输出流中。

4. java.io.ObjectInputStream

   表示对象输入流，它的readObject()方法，从输入流中读取到字节序列，反序列化成为一个对象，最后将其返回。



##### 常见问题

1. 序列化时，如何让某些成员不要序列化？

   可以用transient关键字修饰，它可以阻止修饰的字段被序列化到文件中，在被反序列化后，transient 字段的值被设为初始值，比如int型的值会被设置为 0，对象型初始值会被设置为null。

2. 在 Java 中,Serializable 和 Externalizable 有什么区别

   Externalizable继承了Serializable，给我们提供 writeExternal() 和 readExternal() 方法, 让我们可以控制 Java的序列化机制, 不依赖于Java的默认序列化。正确实现 Externalizable 接口可以显著提高应用程序的性能。

3. serialVersionUID有什么用？

   可以看回本文第七小节哈，JAVA序列化的机制是通过判断类的serialVersionUID来验证版本是否一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同，反序列化成功，如果不相同，就抛出InvalidClassException异常。

4. 是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？

   可以的。我们都知道,对于序列化一个对象需调用 ObjectOutputStream.writeObject(saveThisObject), 并用 ObjectInputStream.readObject() 读取对象, 但 Java 虚拟机为你提供的还有一件事, 是定义这两个方法。如果在类中定义这两种方法, 则 JVM 将调用这两种方法, 而不是应用默认序列化机制。同时，可以声明这些方法为私有方法，以避免被继承、重写或重载。

5. 在 Java 序列化期间,哪些变量未序列化？

   static静态变量和transient 修饰的字段是不会被序列化的。静态（static）成员变量是属于类级别的，而序列化是针对对象的。transient关键字修字段饰，可以阻止该字段被序列化到文件中。



#### 五、序列化方式对比

1. JSON序列化
   - 优点
   - 缺点





